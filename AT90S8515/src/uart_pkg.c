//----------------------------------------------------------------------------
// Автор: Леонид Иванович
//Модуль реализации e

//Формат пакета: FEND, ADD, CMD, LNG, DAT0..DATN, CRC
//Внутри пакета байты FEND и FESC заменяются последовательностями
//TEND-FEND и TFESC-FESC (стаффинг). Адрес передается с установленным
//старшим битом. Команда всегда имеет нулевой старший бит. Это позволяет
//не передавать адрес при работе точка-точка. Длина поля данных в
//пакете может быть от 0 до 255 байт. CRC вычисляется по полиному
//X^8 + X^5 + X^4 + 1 и инициализируется значением 0xDE. CRC вычисляется
//для истинного значения адреса (перед расчетом старший бит нужно
//сбросить). Если адрес не передается, он не участвует в расчете CRC.

//Для того, чтобы модуль можно было использовать с микроконтроллерами,
//имеющими разное количество UART, определены синонимы имен регистров
//и битов UART. Нужно задать эти имена в соответствии с именами
//регистров используемого UART.

//Прием пакета производится в прерывании Rx_Int().
//Если обнаружен маркер начала пакета FEND, начинается прием.
//В прерывании производится дестаффинг данных.
//После приема адреса он сравнивается с заданным адресом Addr,
//если адрес не совпал, обработка пакета прекращается до приема
//следующего маркера начала пакета FEND.
//Если адрес совпал, прием пакета продолжается. Принятый пакет
//сохраняется в буфере приема RxData. Когда прием пакета завершен,
//состояние приема пакета устанавливается в WST_DONE.
//В таком состоянии программа не реагирует на дальнейшие
//поступающие данные.

//Для проверки приема пакета периодически должна вызываться функция
//Wake_GetCmd(). Если в буфере приема находится принятый пакет,
//эта функция подсчитывает контрольную сумму. Если она совпадает,
//функция возвращает код команды (иначе функция возвращает код
//ошибки приема пакета CMD_ERR). Если код отличен от CMD_NOP,
//значит принят пакет, и очередная команда ждет выполнения.
//При этом функция Wake_GetCmd() устанавливает указатели буферов
//приема и передачи на начало данных.
//Принятые данные можно считывать из буфера при помощи функций
//Wake_GetByte(), Wake_GetWord(), Wake_GetDWord(), которые
//возвращают 1, 2 и 4 байта соответственно. Или функцией
//Wake_GetData(), которая копирует по заданному указателю
//заданное количество любых данных из буфера.
//Байты считываются из буфера последовательно.
//Количество принятых байт можно узнать с помощью функции Wake_GetRxCount().
//Для получения доступа к произвольному месту буфера имеется команда
//установки указателя Wake_SetRxPtr().

//После выполнения команды данные, предназначенные для передачи,
//можно загрузить в буфер передачи с помощью функций Wake_AddByte(),
//Wake_AddWord(), Wake_AddDWord(). Функции загружают 1, 2 и 4 байта
//соответственно. Байты загружаются в буфер последовательно. Или функцией
//Wake_AddData(), которая копирует в буфер любые данные, находящиеся
//по заданному указателю. Для получения доступа к произвольному месту
//буфера имеется команда установки указателя Wake_SetTxPtr().
//Когда данные в буфер загружены, можно передавать пакет, для чего
//нужно вызвать функцию Wake_StartTx(). Длина пакета определяется
//автоматически по значению указателя на момент вызова Wake_StartTx().
//Эта функция подсчитывает контрольную сумму для всего пакета и начинает
//передачу. Одновременно она разрешает прием следующего пакета.

//Стандартные команды CMD_ERR, CMD_ECHO, CMD_INFO, CMD_SETADDR,
//CMD_GETADDR обслуживаются этим модулем. Остальные команды
//должны быть обработаны внешним модулем.

//Для работы в режиме RS-485 нужно определить символ RS485.
//При этом будет осуществляться управление направлением.
//Для этого должен быть определен порт DIR и соответствующие
//макросы Port_DIR_1 и Port_DIR_0.

//Возможно формирование задержки ответа на команду, что может быть
//необходимо в режиме RS-485 для того, чтобы на стороне компьютера
//порт успел переключиться на прием. Задержка задается с помощью
//константы TX_DELAY в миллисекундах. Формирование задержки производит
//функция Wake_Exe(), поэтому в случае использовании задержки эта
//функция должна вызываться в основном цикле.

//При работе в сети может быть включена адресация устройств. Для этого
//должен быть определен символ USE_ADDR. При этом функция Wake_SetAddr()
//будет запоминать адрес в EEPROM, а при инициализации модуля он будет
//оттуда считываться. Если адресация выключена, адрес всегда будет
//равен нулю.

//Для ускорения работы программы можно включить режим табличного
//вычисления CRC. Для этого должен быть определен символ TABLE_CRC.
//В таком случае в памяти программ будет сформирована таблица, которая
//займет дополнительно 256 байт.

//----------------------------------------------------------------------------
#include "uart_pkg.h"
char PROGMEM DeviceName[] = { "Programming AT89Cx051" }; //имя устройства
#define LO(x)    ((char)((x) & 0xFF))
#define HI(x)    ((char)(((x) >> 8) & 0xFF))
#define BYTE1(x) (LO(x))
#define BYTE2(x) (HI(x))
#define BYTE3(x) ((char)(((unsigned long)(x) >> 16) & 0xFF))
#define BYTE4(x) ((char)(((unsigned long)(x) >> 24) & 0xFF))
#define WORD(b1,b0)        (((unsigned int)(b1) << 8) | (b0))
#define DWORD(b3,b2,b1,b0) (((unsigned long)WORD(b3,b2) << 16) | WORD(b1,b0))

//--------------------------- Опции компиляции: ------------------------------

//#define RS485       //включение режима работы по RS-485
//#define TX_DELAY 20 //задержка ответа по RS-485, мс
//#define USE_ADDR    //включение использования адреса устройства  
#define TABLE_CRC   //включение табличного способа расчета CRC

//----------------------------- Константы: -----------------------------------

#define FRAME 36      //максимальная длина пакета без учета служебных данных

//синонимы имен регистров и битов UART:

#define W_UCSRA         UCSRA
#define W_FE            FE
///
#define W_UCSRB         UCSRB
#define W_RXCIE         RXCIE
#define W_TXCIE         TXCIE
#define W_RXEN          RXEN
#define W_TXEN          TXEN
////
#define W_UCSRC         UCSRC
#define W_UCSZ1         UCSZ1
#define W_UCSZ0         UCSZ0
/////
#define W_UBRRL         UBRRL
#define W_UBRRH         UBRRH
#define W_UDR           UDR

enum
{
  PTR_CMD, //смещение в буфере для кода команды
  PTR_LNG, //смещение в буфере для длины пакета
  PTR_DAT  //смещение в буфере для данных
};

//Коды байт-стаффинга:

#define FEND  0xC0    //Frame END
#define FESC  0xDB    //Frame ESCape
#define TFEND 0xDC    //Transposed Frame END
#define TFESC 0xDD    //Transposed Frame ESCape

#define CRC_INIT 0xDE //начальное значение контрольной суммы
#define CRC_FEND 0x82 //начальное значение контрольной суммы с учетом FEND

enum
{
  WST_IDLE, //состояние ожидания
  //WST_ADD,  //прием адреса
  WST_CMD,  //прием команды
  WST_LNG,  //прием длины пакета
  WST_DATA, //прием/передача данных
  WST_CRC,  //прием/передача CRC
  WST_DONE  //состояние готовности
};

//------------------------------- Переменные: --------------------------------

//static uint8_t Addr;                 //адрес устройства
#ifdef USE_ADDR  
__no_init __eeprom int EAddr;     //адрес в EEPROM
#endif

static uint8_t RxState;              //состояние процесса приема
static uint8_t RxStuff;              //признак стаффинга при приеме
static uint8_t *RxPtr;               //указатель буфера приема
static uint8_t *RxEnd;               //значение указателя конца буфера приема
static uint8_t RxCount;              //количество принятых байт
static uint8_t RxData[FRAME + PTR_DAT + 1]; //буфер приема

static uint8_t TxState;              //состояние процесса передачи
static uint8_t TxStuff;              //признак стаффинга при передаче
static uint8_t *TxPtr;               //указатель буфера передачи
static uint8_t *TxEnd;               //значение указателя конца буфера передачи
static uint8_t TxCount;              //количество передаваемых байт
static uint8_t TxData[FRAME + PTR_DAT + 1]; //буфер передачи
#ifdef RS485
static uint8_t TxTimer;              //таймер задержки ответа по RS-485
#endif

//-------------------------------- Функции: ----------------------------------

void Do_Crc8(uint8_t b, uint8_t *crc);  //вычисление контрольной суммы

//------------------------- Инициализация UART: ------------------------------

void uart_pkg_init(void)
{ 
  //8-битная посылка atmega16:
  //W_UCSRC = (1 << W_UCSZ1) | (1 << W_UCSZ0);
  //задание скорости обмена:
  UBRR = 25; // при 8Mhz - 19200, Error 0.2%
  
  //разрешение прерываний по приему и передаче, разрешение приема и передачи:
  UCR = (1 << RXCIE) | (1 << TXCIE) | (1 << RXEN) | (1 << TXEN);

  TxState = WST_DONE;   //готовность передачи
  RxState = WST_IDLE;   //разрешение приема
  TxPtr = TxData + PTR_DAT;        //указатель передачи на данные
}

//----------------------- Установка адреса устройства: -----------------------

/*uint8_t Wake_SetAddr(unsigned int sig, uint8_t addr)
{
#ifdef USE_ADDR         //если используется адресация, 
  if(sig == ADDR_KEY && //если правильная сигнатура
     addr < 128)        //и адрес в допустимом диапазоне
  {
    Addr = addr;        //задание адреса
    EAddr = addr;       //сохранение адреса в EEPROM
    return(1);          //установка адреса прошла успешно
  }
#endif    
  return(0);            //ошибка установки адреса
}
*/
//------------------------ Чтение адреса устройства: -------------------------

//char Wake_GetAddr(void)
//{
//  return(Addr);
//}

//--------------------- Вычисление контрольной суммы: ------------------------
void Do_Crc8(uint8_t b, uint8_t *crc)
{
#ifdef TABLE_CRC
  #define TABLE_READ(i) pgm_read_word(&CrcTable[i]) 
  static uint8_t CrcTable[256] PROGMEM =
  {
    0x00, 0x5E, 0xBC, 0xE2, 0x61, 0x3F, 0xDD, 0x83, 
    0xC2, 0x9C, 0x7E, 0x20, 0xA3, 0xFD, 0x1F, 0x41, 
    0x9D, 0xC3, 0x21, 0x7F, 0xFC, 0xA2, 0x40, 0x1E, 
    0x5F, 0x01, 0xE3, 0xBD, 0x3E, 0x60, 0x82, 0xDC, 
    0x23, 0x7D, 0x9F, 0xC1, 0x42, 0x1C, 0xFE, 0xA0, 
    0xE1, 0xBF, 0x5D, 0x03, 0x80, 0xDE, 0x3C, 0x62, 
    0xBE, 0xE0, 0x02, 0x5C, 0xDF, 0x81, 0x63, 0x3D, 
    0x7C, 0x22, 0xC0, 0x9E, 0x1D, 0x43, 0xA1, 0xFF, 
    0x46, 0x18, 0xFA, 0xA4, 0x27, 0x79, 0x9B, 0xC5, 
    0x84, 0xDA, 0x38, 0x66, 0xE5, 0xBB, 0x59, 0x07, 
    0xDB, 0x85, 0x67, 0x39, 0xBA, 0xE4, 0x06, 0x58, 
    0x19, 0x47, 0xA5, 0xFB, 0x78, 0x26, 0xC4, 0x9A, 
    0x65, 0x3B, 0xD9, 0x87, 0x04, 0x5A, 0xB8, 0xE6, 
    0xA7, 0xF9, 0x1B, 0x45, 0xC6, 0x98, 0x7A, 0x24, 
    0xF8, 0xA6, 0x44, 0x1A, 0x99, 0xC7, 0x25, 0x7B, 
    0x3A, 0x64, 0x86, 0xD8, 0x5B, 0x05, 0xE7, 0xB9, 
    0x8C, 0xD2, 0x30, 0x6E, 0xED, 0xB3, 0x51, 0x0F, 
    0x4E, 0x10, 0xF2, 0xAC, 0x2F, 0x71, 0x93, 0xCD, 
    0x11, 0x4F, 0xAD, 0xF3, 0x70, 0x2E, 0xCC, 0x92, 
    0xD3, 0x8D, 0x6F, 0x31, 0xB2, 0xEC, 0x0E, 0x50, 
    0xAF, 0xF1, 0x13, 0x4D, 0xCE, 0x90, 0x72, 0x2C, 
    0x6D, 0x33, 0xD1, 0x8F, 0x0C, 0x52, 0xB0, 0xEE, 
    0x32, 0x6C, 0x8E, 0xD0, 0x53, 0x0D, 0xEF, 0xB1, 
    0xF0, 0xAE, 0x4C, 0x12, 0x91, 0xCF, 0x2D, 0x73, 
    0xCA, 0x94, 0x76, 0x28, 0xAB, 0xF5, 0x17, 0x49, 
    0x08, 0x56, 0xB4, 0xEA, 0x69, 0x37, 0xD5, 0x8B, 
    0x57, 0x09, 0xEB, 0xB5, 0x36, 0x68, 0x8A, 0xD4, 
    0x95, 0xCB, 0x29, 0x77, 0xF4, 0xAA, 0x48, 0x16, 
    0xE9, 0xB7, 0x55, 0x0B, 0x88, 0xD6, 0x34, 0x6A, 
    0x2B, 0x75, 0x97, 0xC9, 0x4A, 0x14, 0xF6, 0xA8, 
    0x74, 0x2A, 0xC8, 0x96, 0x15, 0x4B, 0xA9, 0xF7, 
    0xB6, 0xE8, 0x0A, 0x54, 0xD7, 0x89, 0x6B, 0x35 
  };
  *crc = TABLE_READ(*crc ^ b); //табличное вычисление
#else  
  uint16_t CRC_; 
  
  CRC_= *crc + (uint16_t)b*211;
  CRC_= CRC_ ^ (CRC_ >> 8); // "миксер" битовый, далее его применяем везде
  *crc = CRC_ & 0xFF; //или просто возвращаем результат как 8, а не 16 бит
  
 /* старый код Автор: Леонид Иванович 
  uint8_t i;
  
  for(i = 0; i < 8; b = b >> 1, i++) //вычисление в цикле
    if((b ^ *crc) & 1) *crc = ((*crc ^ 0x18) >> 1) | 0x80;
     else *crc = (*crc >> 1) & ~0x80;*/
#endif     
}

//----------------------------------------------------------------------------
//----------------------------- Прием пакета: --------------------------------
//----------------------------------------------------------------------------
static uint8_t data;
//------------------- Прерывание UART после приема байта: --------------------
ISR(UART_RX_vect)
{
  uint8_t error_flags = (USR & (1 << W_FE)); //чтение флагов ошибок     
  data = UDR;                 //чтение данных
  if(RxState != WST_DONE){            //если прием разрешен
    if(error_flags){                  //если ошибка,
      RxState = WST_IDLE; return;   //переход к поиску FEND
    }   
    if(data == FEND){                 //обнаружен FEND (из любого состояния)
      RxState = WST_CMD;             //переход к приему кода команды
      RxPtr = RxData;                //указатель на начало буфера
      RxStuff = 0; return;           //нет дестаффинга
    }
    if(data == FESC){                 //принят FESC,
      RxStuff = 1; return;          //начало дестафинга
    }   
    if(RxStuff){                      //если идет дестафинг,
      if(data == TFESC)              //если принят TFESC,
        data = FESC;                 //замена его на FESC
      else if(data == TFEND)         //если принят TFEND,
        data = FEND;                 //замена его на FEND
        else { RxState = WST_IDLE; return; } //иначе ошибка стаффинга
      RxStuff = 0;                   //дестаффинг закончен
    }
    switch(RxState){
    /*case WST_ADD:                    //прием адреса
        RxState = WST_CMD;           //далее - прием команды
        if(data & 0x80){              //если принят адрес,
          data &= ~0x80;             //восстановление значения адреса
          if(data != Addr){           //адрес не совпал,
            RxState = WST_IDLE; 
	    return;  //переход к поиску FEND
	  }   //переход к сохранению адреса
	  break; 
        } else *RxPtr++ = 0;           //сохранение нулевого адреса и сразу переходим к следующему состоянию так как в data у нас "команда"
*/
    case WST_CMD:                    //прием кода команды
        RxState = WST_LNG;           //далее - прием длины пакета
        break;                       //переход к сохранению команды
    case WST_LNG:                    //идет прием длины пакета
        RxState = WST_DATA;          //далее - прием данных            
        if(data > FRAME) data = FRAME;   //ограничение длины пакета
        RxEnd = RxData + PTR_DAT + data; //указатель на конец данных
        break;
    case WST_DATA:                   //идет прием данных
        if(RxPtr == RxEnd)           //если все данные и CRC приняты,
          RxState = WST_DONE;        //прием окончен
        break;
    default: return;
    }
    *RxPtr++ = data;                 //сохранение данных в буфере
  }
}
  
//--------------------- Возвращает текущий код команды: ----------------------

uint8_t Wake_GetCmd(void)
{
  char data;
  char *str;
  uint8_t i;	
  uint8_t cmd = CMD_NOP;
  if(RxState == WST_DONE){            //если прием пакета завершен
    RxCount = RxEnd - RxData - PTR_DAT; //количество принятых байт данных
    uint8_t crc = CRC_FEND;             //инициализация CRC
    RxPtr = RxData;                  //указатель на начало буфера
   // if(!*RxPtr) RxPtr++;             //если адрес нулевой, пропускаем его
    while(RxPtr <= RxEnd)            //для всего буфера
      Do_Crc8(*RxPtr++, &crc);       //считаем CRC 
    RxPtr = RxData + PTR_CMD;        //указатель на код команды
    if(!crc) 
       cmd = *RxPtr;           //если CRC совпадает, код команды
    else  
       cmd = CMD_ERR;           //иначе код ошибки
  //  TxCount = 0;                     //обнуление количества байт для передачи
    RxPtr = RxData + PTR_DAT;        //указатель приема на данные
   // TxPtr = TxData + PTR_DAT;        //указатель передачи на данные
  }
  //обработка стандартных команд:
  if(cmd && (cmd < 4)){
    switch(cmd){
    case CMD_ERR:                    //обработка ошибки
        Wake_AddByte(ERR_TX);        //передача кода ошибки
        Wake_StartTx(cmd);           //начало передачи
        break;
    case CMD_ECHO:                   //команда "эхо"
        for(i = 0; i < RxCount; i++)
          *TxPtr++ = *RxPtr++;       //возврат пакета
        Wake_StartTx(cmd);           //начало передачи
        break;
    case CMD_INFO:                   //команда "инфо"
	str = DeviceName;    
        while ( (data = pgm_read_byte(str++)) ){
         Wake_AddByte(data);//копирование имени в буфер
        }
        Wake_StartTx(cmd);            //начало передачи
        break;
    }
    cmd = CMD_NOP;               //команда обработана
    Wake_EndCmd(); // Закончили обработку входящего пакета 
  }  
  return(cmd);
}

//------------------- Возвращает количество принятых байт: -------------------

uint8_t Wake_GetRxCount(void)
{
  return(RxCount);
}

//----------------- Устанавливает указатель на буфер приема: -----------------

void Wake_SetRxPtr(uint8_t p)
{
  if(p < FRAME)
    RxPtr = RxData + PTR_DAT + p;
}

//--------------------- Читает указатель буфера приема: ----------------------

uint8_t Wake_GetRxPtr(void)
{
  return(RxPtr - RxData - PTR_DAT);
}

//---------------------- Читает байт из буфера приема: -----------------------

uint8_t Wake_GetByte(void)
{
  return(*RxPtr++);
}

int8_t Wake_GetInt8_t(void)
{
  return(*RxPtr++);
}


//--------------------- Читает слово из буфера приема: -----------------------

int16_t Wake_GetInt(void)
{
  uint8_t l = *RxPtr++;
  uint8_t h = *RxPtr++;
  return(WORD(h, l));
}
uint16_t Wake_GetWord(void)     //читает слово из буфера приема
{
  uint8_t l = *RxPtr++;
  uint8_t h = *RxPtr++;
  return(WORD(h, l));
}


//----------------- Читает двойное слово из буфера приема: -------------------

/*long Wake_GetDWord(void)
{
  char b1 = *RxPtr++;
  char b2 = *RxPtr++;
  char b3 = *RxPtr++;
  char b4 = *RxPtr++;
  return(DWORD(b4, b3, b2, b1));
}*/

//--------------------- Читает данные из буфера приема: ----------------------

void Wake_GetData(uint8_t *d, uint8_t count)
{
  uint8_t i; 
  for(i = 0; i < count; i++)
    *d++ = *RxPtr++;
}

void Wake_EndCmd(void)
{
   RxState = WST_IDLE;                //разрешение приема пакета   
}

//----------------------------------------------------------------------------
//-------------------------- Передача пакета: --------------------------------
//----------------------------------------------------------------------------

//---------------- Устанавливает указатель на буфер передачи: ----------------

void Wake_SetTxPtr(uint8_t p)
{
  if(p < FRAME)
    TxPtr = TxData + PTR_DAT + p;
}

//-------------------- Читает указатель буфера передачи: ---------------------

uint8_t Wake_GetTxPtr(void)
{
  return(TxPtr - TxData - PTR_DAT);
}

//--------------------- Помещает байт в буфер передачи: ----------------------

void Wake_AddByte(uint8_t b)
{
  if(TxPtr < TxData + PTR_DAT + FRAME)
    *TxPtr++ = b;
}

//-------------------- Помещает слово в буфер передачи: ----------------------

void Wake_AddInt(int16_t w)    //помещает слово в буфер передачи
{
  if(TxPtr < TxData + PTR_DAT + FRAME - 1)
  {
    *TxPtr++ = LO(w);
    *TxPtr++ = HI(w);
  }
}

void Wake_AddWord(uint16_t w)    //помещает слово в буфер передачи
{
  if(TxPtr < TxData + PTR_DAT + FRAME - 1)
  {
    *TxPtr++ = LO(w);
    *TxPtr++ = HI(w);
  }
}


//---------------- Помещает двойное слово в буфер передачи: ------------------

void Wake_AddDWord(long dw)
{
  if(TxPtr < TxData + PTR_DAT + FRAME - 3)
  {
    *TxPtr++ = BYTE1(dw);
    *TxPtr++ = BYTE2(dw);
    *TxPtr++ = BYTE3(dw);
    *TxPtr++ = BYTE4(dw);
  }
}

//-------------------- Помещает данные в буфер передачи: ---------------------

void Wake_AddData(uint8_t *d, uint8_t count)
{
  uint8_t i;
  if(TxPtr <= (TxData + PTR_DAT + FRAME) - count)
    for(i = 0; i < count; i++)
      *TxPtr++ = *d++;
}

//-------------------------- Начало передачи пакета: -------------------------

void Wake_StartTx(uint8_t cmd)
{
  TxState = WST_DATA;                //состояние передачи данных
   
  TxEnd = TxPtr;                     //указатель конца пакета
  TxCount = TxPtr - TxData - PTR_DAT; //количество байт для передачи
  TxPtr = TxData;                    //указатель на начало буфера
//  *TxPtr++ = Addr | 0x80;            //добавление в буфер адреса
  *TxPtr++ = cmd;                    //добавление в буфер кода команды
  *TxPtr = TxCount;                  //добавление в буфер размера пакета
  uint8_t crc = CRC_FEND;               //инициализация CRC
  TxPtr = TxData;                    //указатель на начало буфера
 // if(!Addr) TxPtr++;                 //пропускаем нулевой адрес
  while(TxPtr < TxEnd)
    Do_Crc8(*TxPtr++, &crc);         //расчет CRC для всего буфера
  *TxPtr = crc;                      //добавление в буфер CRC
  TxPtr = TxData;                    //указатель на начало буфера
//  if(!Addr) TxPtr++;                 //пропускаем нулевой адрес
  TxStuff = 0;                       //нет стаффинга
  //RxState = WST_IDLE;                //разрешение приема пакета
#if TX_DELAY == 0
  #ifdef RS485
      Port_DIR_1;                    //переключение RS-485 на передачу
  #endif
  
  W_UDR = FEND;                      //начало передачи
#else  
  TxTimer = ms2sys(TX_DELAY);        //если режим RS-485, то задержка ответа
  TxState = WST_IDLE;                //состояние ожидания передачи
#endif  
}

//------------------------- Задержка передачи ответа: ------------------------

/*void Wake_Exe(bool t)
{
#if TX_DELAY != 0
  if(TxState == WST_IDLE)            //если есть запрос передачи
  {
    if(TxTimer == 0)                 //и задержка ответа истекла
    {
  #ifdef RS485
      Port_DIR_1;                    //переключение RS-485 на передачу
  #endif
      TxState = WST_DATA;            //состояние передачи данных
      W_UDR = FEND;                  //начало передачи
    }
    else
      if(t) TxTimer--;               //иначе декремент таймера
  }
#endif
}*/

//------------------ Прерывание UART после передачи байта: -------------------
ISR(UART_TX_vect)
{
  if(TxState == WST_DATA){            //если идет передача данных,
    uint8_t data = *TxPtr++;            //то чтение байта из буфера
    if(data == FEND || data == FESC){ //попытка передать FEND или FESC,
      if(!TxStuff){                   //нужен стаффинг
        data = FESC;                 //передача FESC
        TxStuff = 1;                 //начало стаффинга
        TxPtr--;                     //возврат к тому же байту
      } else {
        if(data == FEND) data = TFEND; //передача TFEND
          else data = TFESC;         //или TFESC
        TxStuff = 0;                 //конец стаффинга
      }
    }  
    UDR = data;                    //передача байта
    if(TxPtr > TxEnd)                //если конец буфера достигнут,
      TxState = WST_CRC;             //передается CRC
  } else {                              //если передача закончена,
      TxPtr = TxData + PTR_DAT;        //указатель передачи на данные
      TxState = WST_DONE;              //передача пакета закончена
#ifdef RS485
    Port_DIR_0;                      //переключение RS-485 на прием
#endif     
  }
}

//------------------- Определение конца передачи пакета: ---------------------

uint8_t Wake_TxAndRx_End(void)
{
  return(TxState == WST_DONE) && (RxState == WST_DONE);
}

//----------------------------------------------------------------------------
